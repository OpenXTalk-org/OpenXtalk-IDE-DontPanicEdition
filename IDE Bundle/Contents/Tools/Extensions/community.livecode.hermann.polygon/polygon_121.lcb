/**
Polygon v121 [-hh fecit, Oct 2016/Oct 2018]

Widget 'hhPolygon' displays a N-sided polygon that may be filled with built-in patterns.
++ DoubleClick starts/stops edit mode of vertices (moves them).
++ RightClick a vertex to have a menu for deleting it or insert one further vertex.
++ RightClicking and dragging _inside_ the (opaque parts of the) polygon moves the shape.

The widget passes the following messages to LC Script (you can use them in your widget's script):
mouseEnter, mouseLeave, mouseUp.

**/

widget community.livecode.hermann.polygon

use com.livecode.math
use com.livecode.canvas
use com.livecode.widget
use com.livecode.engine
use com.livecode.library.widgetutils

constant kWidgetVersion is "hhPolygon_v121 [fat widget]"

metadata title		is "hhPoly"
metadata author	is "Hermann Hoch"
metadata version	is "1.2.1"
metadata preferredSize is "128,128"
metadata svgicon is "M0 63.5 C 0 127,0 127,109.5 127 C 219 127,219 127,219 63.5 C 219 0,219 0,109.5 0 C 0 0,0 0,0 63.5 M148 63 C 148 98,148 98,140.5 98 C 133 98,133 98,133 63 C 133 28,133 28,140.5 28 C 148 28,148 28,148 63 M50.347 36.364 C 63.873 40.546,70.164 51.350,66.418 63.966 C 63.687 73.161,54.638 78.834,40 80.528 C 34.5 81.165,34.5 81.165,34.5 89.332 C 34.5 97.5,34.5 97.5,26.250 97.790 C 18 98.081,18 98.081,18 65.892 C 18 33.703,18 33.703,31.750 34.284 C 39.430 34.609,47.640 35.527,50.347 36.364 M34 58.373 C 34 70,34 70,37.032 70 C 41.237 70,46.426 67.658,48.369 64.883 C 51.034 61.078,50.487 54.577,47.191 50.887 C 44.906 48.331,43.411 47.650,39.191 47.244 C 34 46.746,34 46.746,34 58.373 M106.239 49.372 C 123.594 54.595,129.396 77.180,117.001 91.261 C 112.054 96.882,105.828 99.496,97.5 99.449 C 89.554 99.404,84.579 97.574,79.387 92.789 C 73.951 87.778,71.483 81.544,71.553 72.997 C 71.698 55.310,88.330 43.982,106.239 49.372 M175.766 62.792 C 178.8 70.606,181.557 77,181.893 77 C 182.229 77,184.278 72.388,186.447 66.750 C 194.387 46.112,192.931 47.836,200.576 50.022 C 204.257 51.074,207.490 52.157,207.760 52.427 C 208.150 52.817,183.168 111.707,179.882 118.144 C 179.112 119.653,178.530 119.662,172.772 118.255 C 169.322 117.412,166.135 116.397,165.688 116 C 165.242 115.602,166.704 111.217,168.938 106.256 C 171.172 101.295,173 96.931,173 96.558 C 173 96.184,168.876 86.231,163.835 74.438 C 158.795 62.645,154.915 52.751,155.214 52.452 C 155.953 51.714,168.280 48.196,169.375 48.411 C 169.856 48.506,172.732 54.977,175.766 62.792 M92.117 61.631 C 84.832 66.733,85.583 82.665,93.297 86.654 C 95.805 87.950,96.997 88.018,100.240 87.046 C 106.548 85.156,109.463 76.807,106.960 67.795 C 105.062 60.963,97.534 57.837,92.117 61.631Z"

constant kResList is "buchenberg.jpg,burg.jpg,gs01.png,gs02.png,gs03.png,gs04.png,gs05.png,gs06.png,gs07.png,gs08.png,gs09.png,gs10.png,gs11.png,gs12.png,patt01.jpg,patt02.jpg,water.jpg"

variable mDown as Boolean
variable mDragElement as Number
variable mE as ScriptObject
variable mEdit as Boolean
variable mEffect as Effect
variable mFill as Boolean
variable mFillColor as Color
variable mFillRule as String
variable mImageFill as optional Image
variable mImagePathFill as String
variable mImagePathStroke as String
variable mImageStroke as optional Image
variable mMouse as Point
variable mNotDeleted as Boolean
variable mNumPoints as Number
variable mPaintFill as optional Paint
variable mPaintStroke as optional Paint
variable mPath as Path
variable mPointsList as List
variable mRadius as Number
variable mRadius2 as Number
variable mRightClick as Boolean
variable mRotateBy as Number
variable mScalePatternFill as Boolean
variable mScalePatternStroke as Boolean
variable mSchlaefli as String
variable mShowBounds as Boolean
variable mShowPosition as Boolean
variable mStroke as Boolean
variable mStrokeColor as Color
variable mStrokeWidth as Number
variable mUsePatternFill as Boolean
variable mUsePatternStroke as Boolean
variable mUsesBuiltInFill as Boolean
variable mUsesBuiltInStroke as Boolean
variable mUseStarPolygon as Boolean
variable mUseWhiteColor as Boolean
variable mVerticesColor as Color
variable mWidgetVersion as String
variable myListBounds as Rectangle

--mark PUBLIC HANDLERS

--
public handler OnCreate()
	put kWidgetVersion into mWidgetVersion
	put my script object into mE
	put 8 into mNumPoints
	put 100 into mRadius
	put true into mEdit
	put true into mFill
	put true into mStroke
	put false into mUsePatternFill
	put false into mUsePatternStroke
	put 2 into mStrokeWidth
	put 4 into mRadius2
	put 0 into mRotateBy
	put true into mShowBounds
	put true into mShowPosition
	put circlePoints(mNumPoints, mRadius) into mPointsList
	put polygon path with points mPointsList into mPath
	put "even odd" into mFillRule
	put color [0.0, 0.5, 0.5, 0.4] into mFillColor
	put color [1.0, 0.75, 0.0] into mStrokeColor
	put color [0.0, 1.0, 0.0, 0.7] into mVerticesColor
	put outer shadow effect into mEffect
	set the color of mEffect to color [1.0,1.0,1.0]
	set the angle of mEffect to 60
	set the size of mEffect to 0.1
	set the spread of mEffect to 0
	put "water.jpg" into mImagePathFill
	put "patt02.jpg" into mImagePathStroke
	put true into mUsesBuiltInFill
	put true into mUsesBuiltInStroke
	put false into mUseWhiteColor
	put "8_3" into mSchlaefli
	put false into mUseStarPolygon
	put image from resource file mImagePathFill into mImageFill
	put image from resource file mImagePathStroke into mImageStroke
	put true into mNotDeleted
end handler

--
public handler OnOpen()
	if mPointsList is [] or mPointsList is nothing then
		resetPath()
	else
		put polygon path with points mPointsList into mPath
		setMyRect()
	end if
end handler
--
public handler OnTimer()
	if mDown then
		variable tMouse as Point
		put the mouse position into tMouse
		if mDragElement > 0 then
			put point [the x of tMouse,the y of tMouse] into mPointsList[mDragElement]
			put polygon path with points mPointsList into mPath
		else if mDragElement = 0 and mRightClick then
			variable tRect as Rectangle
			put my rectangle into tRect
			set property "left" of mE to (the left of tRect + the x of tMouse - the x of mMouse)
			set property "top"	of mE to (the top of tRect + the y of tMouse - the y of mMouse)
		end if
		setMyRect()
		redraw all
		schedule timer in 0.08 seconds
	end if
end handler

--
public handler OnPaint()
	put the number of elements in mPointsList into mNumPoints
		if mUsePatternFill then
			set the image resize quality of this canvas to "high"
		createImagePaintFill()
	end if
	if mFill then
		if not mUsePatternFill then
			set the paint of this canvas to solid paint with mFillColor
		else
			set the paint of this canvas to mPaintFill
		end if
		set the fill rule of this canvas to mFillRule
		fill mPath on this canvas
	end if
		if mUsePatternStroke then
			set the image resize quality of this canvas to "high"
		createImagePaintStroke()
	end if
	if mStroke then
		if not mUsePatternStroke then
			set the paint of this canvas to solid paint with mStrokeColor
		else
			set the paint of this canvas to mPaintStroke
		end if
		set the stroke width of this canvas to mStrokeWidth
		set the join style of this canvas to "round"
		stroke mPath on this canvas
	end if
	if mDown and mNotDeleted and mShowPosition then
		variable tMouse as Point
		variable tBounds as Rectangle
		variable tLocal as String
		variable tGlobal as String
		variable tInfoPoint as Point
		variable tInfoPoint2 as Point
		put the mouse position into tMouse
		if tMouse is within my bounds then
			put " " & ((the x of tMouse) formatted as string) &","& \
				((the y of tMouse) formatted as string) & " " into tLocal
			put "[" & ((the left of my rectangle + the x of tMouse) formatted as string) &","& \
				((the top of my rectangle + the y of tMouse) formatted as string) & "]" into tGlobal
			put the bounds of text tGlobal on this canvas into tBounds
			put hhInfoPoint(tMouse, my bounds, tBounds) into tInfoPoint
			put point [the x of tInfoPoint, 12+ the y of tInfoPoint] into tInfoPoint2
			if the red of mFillColor < 0.5 and the blue of mFillColor < 0.25 and \
					not mUsePatternFill then
				set the paint of this canvas to solid paint with color [1.0,0.0,0.5]
			else
				if mUseWhiteColor then
					set the paint of this canvas to solid paint with color [1.0,1.0,1.0]
				else
					set the paint of this canvas to solid paint with color [0.0,0.0,0.0]
				end if
			end if
			-- begin layer with mEffect on this canvas
				fill text tGlobal at tInfoPoint2 on this canvas
				fill text tLocal at tInfoPoint on this canvas
			--end layer on this canvas
		end if	
	end if
	if mEdit then
		set the paint of this canvas to solid paint with mVerticesColor
		variable tC as Number
		repeat with tC from 1 up to mNumPoints
			fill circle path centered at mPointsList[tC] with radius mRadius2 on this canvas
		end repeat
	end if
	if mShowBounds then
		set the paint of this canvas to solid paint with color [0.0, 0.5, 1.0]
		set the stroke width of this canvas to 1
		set the dashes of this canvas to [8, 3]
		stroke rectangle path of my bounds on this canvas
	end if
end handler

--
public handler OnSave(out rProp as Array)
	put mNumPoints into rProp["numPoints"]
	put mRadius into rProp["radius"]
	put mEdit into rProp["edit"]
	put mShowPosition into rProp["showPosition"]
	put mUseWhiteColor into rProp["useWhiteColor"]
	put mRotateBy into rProp["rotateBy"]
	put mFill into rProp["fill"]
	put mStroke into rProp["stroke"]
	put mStrokeWidth into rProp["strokeWidth"]
	put mRadius2 into rProp["radius2"]
	put mUsePatternFill into rProp["usePatternFill"]
	put mUsePatternStroke into rProp["usePatternStroke"]
	put mScalePatternFill into rProp["scalePatternFill"]
	put mScalePatternStroke into rProp["scalePatternStroke"]
	put mFillRule into rProp["fillRule"]
	put hhColorToString(mFillColor) into rProp["fillColor"]
	put hhColorToString(mStrokeColor) into rProp["strokeColor"]
	put hhColorToString(mVerticesColor) into rProp["verticesColor"]
	put mImagePathFill into rProp["imagePathFill"]
	put mImagePathStroke into rProp["imagePathStroke"]
	put mUsesBuiltInFill into rProp["usesBuiltInFill"]	
	put false into mUseWhiteColor
	put mUseStarPolygon into rProp["useStarPolygon"]	
	put mSchlaefli into rProp["schlaefli"]	
	put hhPointsListToString(mPointsList) into rProp["pointsList"]
end handler

-- 
public handler OnLoad(in rProp as Array)
	put my script object into mE
	if "numPoints" is not among the keys of rProp then
		put 5 into mNumPoints
	else
		put rProp["numPoints"] into mNumPoints
	end if
	if "radius" is not among the keys of rProp then
		put 5 into mRadius
	else
		put rProp["radius"] into mRadius
	end if
	if "edit" is not among the keys of rProp then
		put true into mEdit
	else
		put rProp["edit"] into mEdit
	end if
	if "showPosition" is not among the keys of rProp then
		put false into mShowPosition
	else
		put rProp["showPosition"] into mShowPosition
	end if
	if "useWhiteColor" is not among the keys of rProp then
		put false into mUseWhiteColor
	else
		put rProp["useWhiteColor"] into mUseWhiteColor
	end if
	if "fill" is not among the keys of rProp then
		put false into mFill
	else
		put rProp["fill"] into mFill
	end if
	if "stroke" is not among the keys of rProp then
		put false into mStroke
	else
		put rProp["stroke"] into mStroke
	end if
	if "strokeWidth" is not among the keys of rProp then
		put 2 into mStrokeWidth
	else
		put rProp["strokeWidth"] into mStrokeWidth
	end if
	if "radius2" is not among the keys of rProp then
		setStrokeWidth(mStrokeWidth)
	else
		put rProp["radius2"] into mRadius2
	end if
	if "rotateBy" is not among the keys of rProp then
		put 0 into mRotateBy
	else
		put rProp["rotateBy"] into mRotateBy
	end if
	if "usePatternFill" is not among the keys of rProp then
		put false into mUsePatternFill
	else
		put rProp["usePatternFill"] into mUsePatternFill
	end if
	if "usePatternStroke" is not among the keys of rProp then
		put false into mUsePatternStroke
	else
		put rProp["usePatternStroke"] into mUsePatternStroke
	end if
	if "fillRule" is not among the keys of rProp then
		put "even odd" into mFillRule
	else
		put rProp["fillRule"] into mFillRule
	end if
	if "fillColor" is not among the keys of rProp then
		setFillColor("0.2, 0.2, 0.2")
	else
		setFillColor(rProp["fillColor"])
	end if
	if "strokeColor" is not among the keys of rProp then
		setStrokeColor("1.0, 0.5, 0.0")
	else
		setStrokeColor(rProp["strokeColor"])
	end if
	if "verticesColor" is not among the keys of rProp then
		setVerticesColor("0.0, 0.0, 1.0, 0.62")
	else
		setVerticesColor(rProp["verticesColor"])
	end if
	if "scalePatternFill" is not among the keys of rProp then
		put true into mScalePatternFill
	else
		put rProp["scalePatternFill"] into mScalePatternFill
	end if
	if "scalePatternStroke" is not among the keys of rProp then
		put true into mScalePatternStroke
	else
		put rProp["scalePatternStroke"] into mScalePatternStroke
	end if
	if "usesBuiltInFill" is not among the keys of rProp then
		put true into mUsesBuiltInFill
	else
		put rProp["usesBuiltInFill"] into mUsesBuiltInFill
	end if
	if "usesBuiltInStroke" is not among the keys of rProp then
		put true into mUsesBuiltInStroke
	else
		put rProp["usesBuiltInStroke"] into mUsesBuiltInStroke
	end if
	if "imagePathFill" is not among the keys of rProp then
		put "water.jpg" into mImagePathFill
		put true into mUsesBuiltInFill
	else
		put rProp["imagePathFill"] into mImagePathFill
	end if
	if "imagePathStroke" is not among the keys of rProp then
		put "water.jpg" into mImagePathStroke
		put true into mUsesBuiltInStroke
	else
		put rProp["imagePathStroke"] into mImagePathStroke
	end if
	if mUsesBuiltInFill then
		setBuiltinFill(mImagePathFill)
	else
		setImagePathFill(mImagePathFill)
	end if
	if mUsesBuiltInStroke then
		setBuiltinStroke(mImagePathStroke)
	else
		setImagePathStroke(mImagePathStroke)
	end if
	put hhStringToPointsList(rProp["pointsList"]) into mPointsList
	if "schlaefli" is not among the keys of rProp then
		put "8_3" into mSchlaefli
	else
		put rProp["schlaefli"] into mSchlaefli
	end if
	if "useStarPolygon" is not among the keys of rProp then
		put false into mUseStarPolygon
	else
		put rProp["useStarPolygon"] into mUseStarPolygon
	end if
end handler

public handler OnGeometryChanged()
	variable tBounds as Rectangle
	variable tBoundsLoc as Point
	variable tBounds2 as Rectangle
	variable tBoundsLoc2 as Point
	variable tX as Number
	variable tY as Number
	variable tC as Number
	put the bounding box of mPath into tBounds
	put (my width	 - 2*mRadius2) / (the width	 of tBounds) into tX
	put (my height - 2*mRadius2) / (the height of tBounds) into tY
	repeat with tC from 1 up to the number of elements in mPointsList
		variable tPoint as Point
		put mPointsList[tC] into tPoint
			put point [mRadius2 + tX*(the x of tPoint-mRadius2), mRadius2 + tY*(the y of tPoint-mRadius2)] into mPointsList[tC]
	end repeat
	put polygon path with points mPointsList into mPath
	put the maximum of (-mRadius2 + my width/2) and (-mRadius2 + my height/2) into mRadius
end handler

--mark MOUSE HANDLERS

--
public handler OnMouseDown()
		put true into mDown
		put (the click button is 3) into mRightClick
		put the click position into mMouse
		put -1 into mDragElement
	if pointInShape(mMouse) then
		put 0 into mDragElement
	end if
	if the click count is 2 then
		put not mEdit into mEdit
		redraw all
	end if
	cancel timer
	put true into mNotDeleted
	if mEdit then
		variable tC as Number
		repeat with tC from 1 up to mNumPoints
			if mMouse is within the bounding box of circle path centered at mPointsList[tC] with radius mRadius2 then
				put tC into mDragElement
				exit repeat
			end if
		end repeat
		if mRightClick and mDragElement > 0 then
			popup menu "Insert Point\nDeletePoint" at mPointsList[mDragElement]
			if the result is not nothing then
				if the result is "Insert Point" then
					duplicatePointIntoList(mDragElement,mPointsList)
					put the click position into mPointsList[mDragElement]
				else if the result is "DeletePoint" then
					deletePointFromList(mDragElement,mPointsList)
					put 0 into mDragElement
					put false into mNotDeleted
				end if
				put the number of elements in mPointsList into mNumPoints
				put polygon path with points mPointsList into mPath
				setMyRect()
				redraw all
			end if
		else
			if mShowPosition then
				post "lock cursor; set cursor to cross"
			end if
			schedule timer in 0.08 seconds
		end if
	else
		if mShowPosition then
					post "lock cursor; set cursor to cross"
		end if
		schedule timer in 0.08 seconds
	end if
end handler

--
public handler OnMouseUp()
	put false into mDown
	cancel timer
	if not mEdit then
		post "unlock cursor; mouseUp" to mE
	else
		post "unlock cursor" to mE
	end if
	redraw all
end handler

--
public handler OnMouseRelease()
	put false into mDown
	cancel timer
	post "unlock cursor" to mE
	redraw all
end handler

--
public handler OnMouseEnter()
	post "mouseEnter" to mE
end handler

--
public handler OnMouseLeave()
	post "mouseLeave" to mE
end handler

--mark HANDLERS

--
handler resetPath() returns nothing
	variable tRect as Rectangle
	put my rectangle into tRect
	if mUseStarPolygon then
		put circlePoints2(mSchlaefli, mRadius) into mPointsList
		put polyline path with points mPointsList into mPath
	else
		put circlePoints(mNumPoints, mRadius) into mPointsList
		put polygon path with points mPointsList into mPath
	end if
	put polygon path with points mPointsList into mPath
	setMyRect()
	set property "top" of mE to the top of tRect
	set property "left" of mE to the left of tRect
	redraw all
end handler

--
handler circlePoints(in pNum as Number, in pRadius as Number) returns List
	variable tPi as Number
	put 2*pi/pNum into tPi
	variable tList as List
	put [] into tList
	variable tC as Number
	repeat with tC from 1 up to pNum
		push point [pRadius*sin(tC*tPi), pRadius*cos(tC*tPi)] onto tList
	end repeat
	return tList
end handler

--
handler circlePoints2(in pSchlaefli as String, in pRadius as Number) returns List
	variable tPi as Number
	variable tNum as Number
	variable tStep as Number
	variable tS as List
	variable tList as List
	split pSchlaefli by "_" into tS
	put (element 1 of tS parsed as number) into tNum
	put (element 2 of tS parsed as number) into tStep
	put tNum into mNumPoints
	put 2*pi/tNum into tPi
	put [] into tList
	variable tC as Number
	repeat with tC from 0 up to tStep*tNum - tStep+1 by tStep
		push point [pRadius*sin(tC*tPi), pRadius*cos(tC*tPi)] onto tList
	end repeat
	return tList
end handler

--
handler getBounds() returns Rectangle
	variable tPoint as Point
	variable tXList as List
	variable tYList as List
	put the empty list into tXList
	put the empty list into tYList
	if mPointsList is [] then
			put circlePoints(mNumPoints, mRadius) into mPointsList
	end if
	if mPointsList is [] then
		put circlePoints(mNumPoints, mRadius) into mPointsList
	end if
 repeat for each element tPoint in mPointsList
		push the x of tPoint onto tXList
		push the y of tPoint onto tYList
	end repeat
	variable tW
	put mRadius2 into tW
		return rectangle [-tW + the minimum value of tXList, -tW + the minimum value of tYList, tW + the maximum value of tXList, tW + the maximum value of tYList ]
end handler

--
handler setMyRect() returns nothing
	variable tRect as Rectangle
	variable tBounds as Rectangle
	variable tRectNew as String
	put my rectangle into tRect
	put getBounds() into tBounds
	put ((the left of tRect + the left	 of tBounds) formatted as string) & "," & \
		((the top of tRect + the top		 of tBounds) formatted as string) & "," & \
		((the left of tRect + the right	 of tBounds) formatted as string) & "," & \
		((the top of tRect + the bottom of tBounds) formatted as string) into tRectNew
	set property "rect" of mE to tRectNew
	put getBounds() into tBounds
	variable tC as Number
	repeat with tC from 1 up to mNumPoints
		variable tPoint as Point
		put mPointsList[tC] into tPoint
		put point	 [the x of tPoint - the left of tBounds, \
					the y of tPoint - the top of tBounds] into mPointsList[tC]
	end repeat
	put polygon path with points mPointsList into mPath
end handler

--
handler setSchlaefli(in pSchlaefli as String) returns nothing
	put pSchlaefli into mSchlaefli
	if mUseStarPolygon then
		resetPath()
	end if
end handler

--
handler setUseStarPolygon(in pBool as Boolean)
	put pBool into mUseStarPolygon
	resetPath()
end handler

--
handler setShowBounds(in pBool as Boolean)
	put pBool into mShowBounds
	redraw all
end handler

--
handler createImagePaintFill() returns nothing
	if mImageFill is not nothing then
		put pattern with mImageFill into mPaintFill
		if mScalePatternFill then
			scale mPaintFill by [my width/the width of mImageFill, my height/the height of mImageFill]
		end if
	else
		put solid paint with color [1.0,0.0,0.0] into mPaintFill
	end if
end handler

--
handler createImagePaintStroke() returns nothing
	if mImageStroke is not nothing then
		put pattern with mImageStroke into mPaintStroke
		if mScalePatternStroke then
			scale mPaintStroke by [my width/the width of mImageStroke, my height/the height of mImageStroke]
		end if
	else
		put solid paint with color [1.0,0.0,0.0] into mPaintStroke
	end if
end handler

--
handler loadImageFill() returns nothing
	if mImagePathFill is not empty then
		put false into mUsesBuiltInFill
		put image from file mImagePathFill into mImageFill
	else
		put "water.jpg" into mImagePathFill
		put true into mUsesBuiltInFill
		put image from resource file mImagePathFill into mImageFill
	end if
end handler

--
handler loadImageStroke() returns nothing
	if mImagePathStroke is not empty then
		put false into mUsesBuiltInStroke
		put image from file mImagePathStroke into mImageStroke
	else
		put "water.jpg" into mImagePathStroke
		put true into mUsesBuiltInStroke
		put image from resource file mImagePathStroke into mImageStroke
	end if
end handler

--mark GETTER and SETTER

--
handler getBuiltInFill() returns String
	variable tS as List
	split kResList by "," into tS
	if mImagePathFill is not among the elements of tS then 
		return "water.jpg"
	else
		put true into mUsesBuiltInFill
		return mImagePathFill
	end if
end handler

--
handler getBuiltInStroke() returns String
	variable tS as List
	split kResList by "," into tS
	if mImagePathStroke is not among the elements of tS then 
		return "water.jpg"
	else
		put true into mUsesBuiltInStroke
		return mImagePathStroke
	end if
end handler

--
handler setBuiltInFill(in pPath as String) returns nothing
	put pPath into mImagePathFill
	put true into mUsesBuiltInFill
	put image from resource file mImagePathFill into mImageFill
	redraw all
end handler

--
handler setBuiltInStroke(in pPath as String) returns nothing
	put pPath into mImagePathStroke
	put true into mUsesBuiltInStroke
	put image from resource file mImagePathStroke into mImageStroke
	redraw all
end handler

--
handler setImagePathFill(in pPath as String) returns nothing
	put pPath into mImagePathFill
	put false into mUsesBuiltInFill
	loadImageFill()
	redraw all
end handler

--
handler setImagePathStroke(in pPath as String) returns nothing
	put pPath into mImagePathStroke
	put false into mUsesBuiltInStroke
	loadImageStroke()
	redraw all
end handler

--
handler setRotateBy(in pValue as Number) returns nothing
	put the trunc of pValue into pValue
	variable tC as Number
	variable tS as Number
	put cos(-pValue*pi/180) into tC
	put sin(-pValue*pi/180) into tS
	if the abs of tC < 10^(-9) then
		put 0 into tC
	end if
	if the abs of tS < 10^(-9) then
		put 0 into tS
	end if
	variable tN as Number
	variable tX as Number
	variable tY as Number
	variable tPoint as Point
	put my width/2 into tX
	put my height/2 into tY
	repeat with tN from 1 up to the number of elements in mPointsList
		put mPointsList[tN] into tPoint
		put point	 [tX+ tC*(the x of tPoint-tX)+tS*(the y of tPoint-tY), \
			tY + tC*(the y of tPoint-tY)-tS*(the x of tPoint-tX)] into mPointsList[tN]
	end repeat
	put polygon path with points mPointsList into mPath
	setMyRect()
	redraw all
end handler

--
handler setPolyPoints(in pString as String) returns nothing
	put hhStringToPointsList(pString) into mPointsList
	put the number of elements in mPointsList into mNumPoints
	put polygon path with points mPointsList into mPath
	setMyRect()
	redraw all
end handler

--
handler getPolyPoints() returns String
	return hhPointsListToString(mPointsList)
end handler

--
handler setEditMode(in pBool as Boolean) returns nothing
	put pBool into mEdit
	redraw all
end handler

--
handler setUsePatternFill(in pBool as Boolean) returns nothing
	put pBool into mUsePatternFill
	redraw all
end handler

--
handler setUsePatternStroke(in pBool as Boolean) returns nothing
	put pBool into mUsePatternStroke
	redraw all
end handler

--
handler setStrokeWidth(in pNum as Number) returns nothing
	-- avoid jumping with odd integers
	if pNum > 8 then
		put the maximum of 1 and (2*the trunc of (pNum/2)) into mStrokeWidth
	else
		put the maximum of 1 and (the trunc of pNum) into mStrokeWidth
	end if
	put the maximum of 4 and (the trunc of (mStrokeWidth/2)) into mRadius2
	redraw all
end handler

--
handler setNumPoints(in pNum as Number) returns nothing
	put the maximum of 3 and (the rounded of pNum) into mNumPoints
	put false into mUseStarPolygon
	resetPath()
end handler

--
handler setRadius(in pNum as Number) returns nothing
	put pNum into mRadius
	resetPath()
end handler

--
handler setFill(in pBool as Boolean) returns nothing
	put pBool into mFill
	if not mFill then
		put true into mStroke
	end if
	redraw all
end handler

--
handler setFillRule(in pRule as String) returns nothing
	put pRule into mFillRule
	redraw all
end handler

--
handler setStroke(in pNum as Boolean) returns nothing
	put pNum into mStroke
	if not mStroke then
		put true into mFill
	end if
	redraw all
end handler

--
handler setFillColor(in pColor as String) returns nothing
	put hhStringToColor(pColor) into mFillColor
	redraw all
end handler

--
handler getFillColor() returns String
	return hhColorToString(mFillColor)
end handler

--
handler setStrokeColor(in pColor as String) returns nothing
	put hhStringToColor(pColor) into mStrokeColor
	redraw all
end handler

--
handler getStrokeColor() returns String
	return hhColorToString(mStrokeColor)
end handler

--
handler setVerticesColor(in pColor as String) returns nothing
	put hhStringToColor(pColor) into mVerticesColor
	redraw all
end handler

--
handler getVerticesColor() returns String
	return hhColorToString(mVerticesColor)
end handler

--
handler setScalePatternFill(in pBool as Boolean) returns nothing
	put pBool into mScalePatternFill
	--createImagePaintFill()
	redraw all
end handler

--
handler setScalePatternStroke(in pBool as Boolean) returns nothing
	put pBool into mScalePatternStroke
	--createImagePaintStroke()
	redraw all
end handler

--mark hh-HELPER

-- works for 'even odd' fillRule only
handler pointInShape(in pPoint as Point) returns Boolean
	variable tX0 as Number
	variable tY0 as Number
	put the x of pPoint into tX0
	put the y of pPoint into tY0
	variable nJ as Number
	put mNumPoints into nJ
	variable tCheck as Boolean
	put false into tCheck
	-- ACKNOWLEDGEMENT:
	-- This is essentially the subdivison algorithm by MShimrat (Aug 1962).
	variable tC as Number
	variable tX1 as Number
	variable tX2 as Number
	variable tY1 as Number
	variable tY2 as Number
	repeat with tC from 1 up to mNumPoints
		put the x of mPointsList[tC] into tX1
		put the y of mPointsList[tC] into tY1
		put the x of mPointsList[nJ] into tX2
		put the y of mPointsList[nJ] into tY2
			if ( ((tY1 > tY0) is not (tY2 > tY0)) and \
			( tX0 < tX1 + (tX2-tX1)*(tY0-tY1)/(tY2-tY1) ) ) then
			put not tCheck into tCheck
		end if
		put tC into nJ
	end repeat
	return tCheck
end handler

--
handler deletePointFromList(in pNum as Number, inout xList as List)
	delete element pNum of xList
end handler

--
handler duplicatePointIntoList(in pNum as Number, inout xList as List)
	splice [xList[pNum]] after element pNum of xList
end handler

--
handler hhInfoPoint(in pPoint as Point, pRect as Rectangle, pBounds as Rectangle) returns Point
	variable tPoint as Point
	put point [5 + mRadius2 + the x of pPoint, 10 + the y of pPoint] into tPoint
	if the x of pPoint > the width of pRect/2 then
		subtract 12+mRadius2+the width of pBounds from the x of tPoint
	end if 
	if the y of pPoint > the height of pRect/2 then
		subtract 5+mRadius2+the height of pBounds from the y of tPoint
	end if
	return tPoint
end handler

--
handler hhStringToColor(in pString as String) returns Color
	if the number of chars in pString is 0 then
		 return color [0.0, 0.0, 0.0, 1.0]
	end if
	variable tList as List
	split pString by "," into tList
	variable tNum as Number
	put the number of elements in tList into tNum
	variable tR as Number
	variable tG as Number
	variable tB as Number
	variable tA as Number 
	put ((element 1 of tList) parsed as number) into tR
	put ((element 2 of tList) parsed as number) into tG
	put ((element 3 of tList) parsed as number) into tB
	if tNum = 4 then -- put first tA in range 0-1
		put ((element 4 of tList) parsed as number) into tA
		if not ("." is in pString) then
			put tA/255 into tA
		end if
	else
		put 1.0 into tA
	end if
	if "." is in pString then
		return color [tR, tG, tB, tA]
	else
		return color [tR/255, tG/255, tB/255, tA]
	end if
end handler

-- Returns the color as a four-item string
handler hhColorToString(in pColor as Color) returns String
	variable tString as String
	if pColor is nothing then
		return "0,0,0,255"
	end if
	put (the trunc of ((the red of pColor) * 255)) formatted as string into tString
	put "," & (the trunc of ((the green of pColor) * 255)) formatted as string after tString
	put "," & (the trunc of ((the blue of pColor) * 255)) formatted as string after tString
	put "," & (the trunc of ((the alpha of pColor) * 255)) formatted as string after tString
	return tString
end handler

-- converts a string of LCS points into a list of LCB points
handler hhStringToPointsList(in pString as String) returns List
	variable tC as Number
	variable tL1 as List
	variable tL2 as List
	variable tS	 as List
	split pString by newline into tL1
	put [] into tL2
	repeat with tC from 1 up to the number of elements in tL1
		split tL1[tC] by "," into tS
		push point [(tS[1] parsed as number),(tS[2] parsed as number)] onto tL2
	end repeat
	return tL2
end handler

-- converts a list of LCB points into a string of LCS points
handler hhPointsListToString(in pList as List) returns String
	variable tC as Number
	variable tP as Point
	variable tL as List
	variable tS as String
	put [] into tL
	repeat with tC from 1 up to the number of elements in pList
		put pList[tC] into tP
		push (the x of tP formatted as string) & "," & (the y of tP formatted as string) onto tL
	end repeat
	combine tL with newline into tS
	return tS
end handler

-- pX, pY are the x and y of the rotation center
handler hhRotatingTransform(in pAngle as Number, in pX as Number, in pY as Number) returns Transform
	variable tC as Number
	variable tS as Number
	put cos(pAngle*pi/180) into tC
	put sin(pAngle*pi/180) into tS
		if the abs of tC < 10^(-9) then
		put 0 into tC
	end if
	if the abs of tS < 10^(-9) then
		put 0 into tS
	end if
	return transform with matrix [tC, tS, -tS, tC, (1-tC)*pX+tS*pY, (1-tC)*pY-tS*pX]
end handler

--mark PROPERTIES

property widgetVersion get mWidgetVersion

--mark polyPoints
/**
Syntax:
set the polyPoints of <widget> to <pLinesOfPoints>
get the polyPoints of <widget>

Parameters:
pLinesOfPoints: is a string of points, one point per line, NO empty lines (as the polygon is not 'interrupted').

Examples:
set the polyPoints of widget "hhPolygon" to the points of graphic 1
get the polyPoints of widget "hhPolygon"

Summary: The polyPoints is intended to be a 'connector' to polygon graphic objects in LC Script.

Description:
The polyPoints is a string of at least two lines containing a point "x,y" in each line. Empty lines are not allowed. You may use this property also for exact positioning in the property inspector.
**/
property polyPoints get getPolyPoints set setPolyPoints
metadata polyPoints.editor	is "com.livecode.pi.text" 
metadata polyPoints.section is "Contents" 

--mark regularStarPolygon
/**
Syntax:
set the regularStarPolygon of <widget> to <pString>
get the regularStarPolygon of <widget>

Parameters:
pString: is a string of the form "N_M". N is the number of vertices, M the step when setting the order of the vertices of the regular polygon (this combination is called a Schlaefli symbol).

Examples:
set the regularStarPolygon of widget "hhPolygon" to "8_3"
get the regularStarPolygon of widget "hhPolygon"

Summary: The regularStarPolygon sets the Schlaefli symbol "N_M" of the regular star polygon.

Description:
The regularStarPolygon is a string of the form "N_M". N is the number of vertices, M the step when setting the order of the vertices of the regular polygon; this combination is called a Schlaefli symbol. It is M < N/2 and N and M have no common divisor.
(See https://en.wikipedia.org/wiki/List_of_regular_polytopes_and_compounds#Stars)
**/
property regularStarPolygon get mSchlaefli	set setSchlaefli
metadata regularStarPolygon.editor	is "com.livecode.pi.enum"
metadata regularStarPolygon.options is "5_2,7_2,7_3,8_3,9_2,9_4,10_3,11_2,11_3,11_4,11_5,12_5,13_2,13_3,13_4,13_5,13_6,14_3,14_5,15_2,15_4,15_7,16_3,16_5,16_7,17_2,17_3,17_4,17_5,17_6,17_7,17_8,18_5,18_7,19_2,19_3,19_4,19_5,19_6,19_7,19_8,19_9,20_3,20_7,20_9"
metadata regularStarPolygon.default is "8_3"

-- mark useStarPolygon
/**
Syntax:
set the useStarPolygon of <widget> to <pTrueOrFalse>
get the useStarPolygon of <widget>

Parameters:
pTrueOrFalse: is true or false

Example:
set the useStarPolygon of widget "hhPolygon" to not \
		the useStarPolygon of widget "hhPolygon"

Summary: useStarPolygon activates a star polygon (with current Schlaefli symbol) to be drawn.

Description:
Use the useStarPolygon property to determine that a star polygon (with current Schlaefli symbol) is used. If set to false a 'usual' regular polygon is drawn.
**/
property useStarPolygon get mUseStarPolygon set setUseStarPolygon

--mark numOfVertices
/**
Syntax:
set the numOfVertices of <widget> to <pNum>
get the numOfVertices of <widget>

Parameters:
pNum: is an Integer (at least 3).

Examples:
set the numOfVertices of widget "hhPolygon" to 12 -- regular 12-gon
get the numOfVertices of widget "hhPolygon"

Summary: The numOfVertices sets the number of vertices of the (regular) polygon.

Description:
Use the numOfVertices property to determine the number N of the regular N-gon. Choosing a new number of vertices RESETS the current vertices of widget!
**/
property numOfVertices get mNumPoints	 set setNumPoints
metadata numOfVertices.editor is "com.livecode.pi.number"
metadata numOfVertices.min		is "3"
metadata numOfVertices.max		is "128"
metadata numOfVertices.step		is "1"

--mark radius
/**
Syntax:
set the radius of <widget> to <pNum>
get the radius of <widget>

Parameters:
pNum: is a positive number

Examples:
set the radius of widget "hhPolygon" to 100 -- 100 pixels
get the radius of widget "hhPolygon"

Summary: The radius sets the radius of the circle that contains the vertices of the regular polygon.

Description:
Use the radius property to determine the width and height the regular N-gon. Choosing a new value for the radius changes the width and height of the widget to 2*radius also if it isn't a regular polygon any more.
**/
property "radius" get mRadius set setRadius
metadata radius.editor		is "com.livecode.pi.number"
metadata radius.min		is "0"
metadata radius.max		is "256"
metadata radius.step	is "1"

--mark editMode
/**
Syntax:
set the editMode of <widget> to <pTrueOrFalse>
get the editMode of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the editMode of widget "hhPolygon" to not \
		the editMode of widget "hhPolygon"

Summary: If set to true property editMode shows "handles"/"markers" at the vertices that you can grab and move. 

Description:
If set to true property editMode shows "handles"/"markers" at the vertices that you can grab and move. The mode may also be started by double-clicking the widget at the polygons 'interior' (opaque parts).
**/
property "editMode" get mEdit set setEditMode

--mark showBounds
/**
Syntax:
set the showBounds of <widget> to <pTrueOrFalse>
get the showBounds of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the showBounds of widget "hhPolygon" to not \
		the showBounds of widget "hhPolygon"

Summary: Whether to show the bounds of the widget.

Description:
If set to true property showBounds shows as dashed line the bounds of the widget. These has always  to be adjusted, so that the widget is the smallest enclosing rectangleof the polygon.
**/
property "showBounds" get mShowBounds set setShowBounds

--mark showMouseDownPosition
/**
Syntax:
set the showMouseDownPosition of <widget> to <pTrueOrFalse>
get the showMouseDownPosition of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the showMouseDownPosition of widget "hhPolygon" to not \
		the showMouseDownPosition of widget "hhPolygon"

Summary: If set to true property showMouseDownPosition shows (x,y) coordinates of the mouse position

Description:
If set to true property showMouseDownPosition shows (x,y) coordinates of the mouse position that are local to the widget's bounds and also the 'usual' card coordinates. Use property	 whitePositionColor to improve visibilty if necessary.
**/
property "showMouseDownPosition" get mShowPosition set mShowPosition

--mark whitePositionColor
/**
Syntax:
set the whitePositionColor of <widget> to <pTrueOrFalse>
get the whitePositionColor of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the whitePositionColor of widget "hhPolygon" to not \
		the whitePositionColor of widget "hhPolygon"

Summary: whitePositionColor sets the color of an activated showMouseDownPosition to white (or black).

Description:
If set to true property whitePositionColor shows while showMouseDownPosition is active the coordinates in white color, else in black color.
**/
property "whitePositionColor" get mUseWhiteColor	set mUseWhiteColor

--mark rotateBy
/**
Syntax:
set the rotateBy of <widget> to <pAngle>
get the rotateBy of <widget>

Parameters:
pAngle: angle in degrees, negative values rotate counter-clockwise, positive values clockwise in degrees. 

Examples:
-- rotate 30 degress cw from current rotation
set the rotateBy of widget "hhPolygon" to	 30
-- rotate 15 degress ccw from current rotation
set the rotateBy of widget "hhPolygon" to -15

Summary: The angle of additive or subtractive rotation of the polygon path (NOT of the pattern). RotateBy is NOT a 'rotateTo'.

Description:
Use the rotateBy property to rotate the polygon <pAngle> degrees clockwise (cw) on base of the current state.
You may also give negative angles which rotate their absolute value counterclockwise (ccw)
For example -15 cw is equivalent to 360-15 cw is equivalent to 15 ccw.
**/
property "rotateBy" get mRotateBy set setRotateBy
metadata rotateBy.editor		is "com.livecode.pi.enum" 
metadata rotateBy.options is "0,+1,-1,+3,-3,+5,-5,+15,-15,+30,-30,+45,-45,+60,-60,+90,-90,180"
metadata rotateBy.default is "0"

--mark builtInImgFill
/**
Syntax:
set the builtInImgFill of <widget> to <pString>

Parameters:
pString: is the name of a 'widget-built-in' image to use for the fill-pattern.

Example:
set the builtInImgFill of widget "hhPolygon" to "water.jpg"

Summary: Chooses one of the widget-built-in images as the available fill-pattern

Description:
Sets the name of the image to use as a fill-pattern to one of the widget-built-in images. This is typically set from the popup menu in the property inspector.
Available choices are currently buchenberg.jpg, burg.jpg, water.jpg, gs01.png, gs02.png, gs03.png, gs04.png, gs05.png, gs06.png, gs07.png, gs08.png, gs09.png, gs10.png, gs11.png, gs12.png, patt01.jpg and patt02.jpg.
**/
property "builtInImgFill" get getBuiltInFill	set setBuiltInFill
metadata builtInImgFill.editor is "com.livecode.pi.enum"
metadata builtInImgFill.options is "buchenberg.jpg,burg.jpg,gs01.png,gs02.png,gs03.png,gs04.png,gs05.png,gs06.png,gs07.png,gs08.png,gs09.png,gs10.png,gs11.png,gs12.png,patt01.jpg,patt02.jpg,water.jpg"
metadata builtInImgFill.default is "water.jpg"
metadata builtInImgFill.section is "Colors"

--mark filenameFill
/**
Syntax:
set the filenameFill of <widget> to <pPath>

Parameters:
pPath: is a full valid filePath to an image to use for the fill-pattern.

Example:
set the filenameFill of widget "hhPolygon" to "/Users/admin/pictures/water.jpg"

Summary: Sets any LC-readable image by its filePath as the available fill-pattern.

Description:
Sets the filePath of the image to use as the fill-pattern. This is typically set from the popup menu in the property inspector (and it's 'answer file'-dialog button right of the filename's text box). 
**/
property "filenameFill" get mImagePathFill	set setImagePathFill
metadata filenameFill.editor is "com.livecode.pi.file"
metadata filenameFill.section is "Colors"

--mark usePatternFill
/**
Syntax:
set the usePatternFill of <widget> to <pTrueOrFalse>
get the usePatternFill of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the usePatternFill of widget "hhPolygon" to not \
		the usePatternFill of widget "hhPolygon"

Summary: If set to true property usePatternFill causes the polygon's path to be filled with the current fill-pattern image. 

Description:
Use the usePatternFill property to determine the fill of the polygon's path. If true then the fill-pattern paint is used, else the fillColor.
**/
property "usePatternFill" get mUsePatternFill		set setUsePatternFill
metadata usePatternFill.section is "Colors"

--mark scalePatternFill
/**
Syntax:
set the scalePatternFill of <widget> to <pTrueOrFalse>
get the scalePatternFill of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the scalePatternFill of widget "hhPolygon" to not \
		the scalePatternFill of widget "hhPolygon"

Summary: If set to true property scalePatternFill causes the the current fill-pattern image to be scaled to fit.

Description:
Use the scalePatternFill property to determine the dimensions of the fill-pattern. If true then the fill-pattern paint is scaled to fit. Else the unscaled fill-pattern is repeated (if small enough).
**/
property "scalePatternFill" get mScalePatternFill set setScalePatternFill
metadata scalePatternFill.section is "Colors"

--mark usePatternStroke
/**
Syntax:
set the usePatternStroke of <widget> to <pTrueOrFalse>
get the usePatternStroke of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the usePatternStroke of widget "hhPolygon" to not \
		the usePatternStroke of widget "hhPolygon"

Summary: If set to true property usePatternStroke causes the polygon's Stroke (outline) to be filled with the current pattern image. 

Description:
Use the usePatternStroke property to determine the stroke (outline) of the polygon's path. If true then the stroke-pattern paint is used for stroking, else the strokeColor.
**/
property "usePatternStroke" get mUsePatternStroke set setUsePatternStroke
metadata usePatternStroke.section is "Colors"

--mark scalePatternStroke
/**
Syntax:
set the scalePatternStroke of <widget> to <pTrueOrFalse>
get the scalePatternStroke of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the scalePatternStroke of widget "hhPolygon" to not \
		the scalePatternStroke of widget "hhPolygon"

Summary: If set to true property scalePatternStroke causes the the current stroke-pattern image to be scaled to fit.

Description:
Use the scalePatternStroke property to determine the dimensions of the stroke-pattern. If true then the stroke-pattern paint is scaled to fit. Else the unscaled stroke-pattern is repeated (if small enough).
**/
property "scalePatternStroke" get mScalePatternStroke set setScalePatternStroke
metadata scalePatternStroke.section is "Colors"

--mark builtInImgStroke
/**
Syntax:
set the builtInImgStroke of <widget> to <pString>

Parameters:
pString: is the name of a 'widget-built-in' image to use for the stroke-pattern.

Example:
set the builtInImgStroke of widget "hhPolygon" to "water.jpg"

Summary: Chooses one of the widget-built-in images as the available stroke-pattern

Description:
Sets the name of the image to use as a stroke-pattern to one of the widget-built-in images. This is typically set from the popup menu in the property inspector.
Available choices are currently buchenberg.jpg, burg.jpg, water.jpg, gs01.png, gs02.png, gs03.png, gs04.png, gs05.png, gs06.png, gs07.png, gs08.png, gs09.png, gs10.png, gs11.png, gs12.png, patt01.jpg and patt02.jpg.
**/
property "builtInImgStroke" get getBuiltInStroke set setBuiltInStroke
metadata builtInImgStroke.editor is "com.livecode.pi.enum"
metadata builtInImgStroke.options is "buchenberg.jpg,burg.jpg,gs01.png,gs02.png,gs03.png,gs04.png,gs05.png,gs06.png,gs07.png,gs08.png,gs09.png,gs10.png,gs11.png,gs12.png,patt01.jpg,patt02.jpg,water.jpg"
metadata builtInImgStroke.default is "patt02.jpg"
metadata builtInImgStroke.section is "Colors"

--mark filenameStroke
/**
Syntax:
set the filenameStroke of <widget> to <pPath>

Parameters:
pPath: is a full valid filePath to an image to use for the stroke-pattern.

Example:
set the filenameStroke of widget "hhPolygon" to "/Users/admin/pictures/water.jpg"

Summary: Sets any LC-readable image by its filePath as the available stroke-pattern.

Description:
Sets the filePath of the image to use as the stroke-pattern. This is typically set from the popup menu in the property inspector (and it's 'answer file'-dialog button right of the filename's text box). 
**/
property "filenameStroke" get mImagePathStroke	set setImagePathStroke
metadata filenameStroke.editor is "com.livecode.pi.file"
metadata filenameStroke.section is "Colors"

--mark fillColor
/**
Syntax:
set the fillColor of <widget> to <pColor>
get the fillColor of <widget>

Summary: Sets or gets the color of the chars fill.

Parameters:
pColor: The color of the text, in RGB or RGBA format

Example:
set the fillColor of widget "hhPolygon" to "255,127,0"
-- returns a _four-item_ string
get the fillColor of widget "hhPolygon" -- "255,127,0,255"
set the fillColor of widget "hhPolygon" to "255,127,0,127"

Description:
Use the fillColor property to set the color of the chars fill.
The color is in the form of a 3 or 4 item string, the 4th optional item being the alpha value, all integers between 0 and 255.
[You may also use numbers containing a decimal point between 0.0 and 1.0, for example "0.2,0.1,0.2".
.: The "get" always returns _four_ items in the integer form (each in range 0-255). :.
**/
property "fillColor" get getFillColor set setFillColor
metadata fillColor.editor		is "com.livecode.pi.colorwithalpha"
metadata fillColor.section		is "Colors"

--mark strokeColor
/**
Syntax:
set the strokeColor of <widget> to <pColor>
get the strokeColor of <widget>

Summary: Sets or gets the color of the path outline (stroke).

Parameters:
pColor: The stroke (outline) color of the text, in RGB or RGBA format

Example:
set the strokeColor of widget "hhPolygon" to "255,127,0"
-- returns a _four-item_ string
get the strokeColor of widget "hhPolygon" -- "255,127,0,255"
set the strokeColor of widget "hhPolygon" to "255,127,0,127"

Description:
Use the strokeColor property to set the color of the path outline.
The color is in the form of a 3 or 4 item string, the 4th optional item being the alpha value, all integers between 0 and 255.
[You may also use numbers containing a decimal point between 0.0 and 1.0, for example "0.2,0.1,0.2".
.: The "get" always returns _four_ items in the integer form (each in range 0-255). :.
**/
property "strokeColor" get getStrokeColor set setStrokeColor
metadata strokeColor.editor		is "com.livecode.pi.colorwithalpha"
metadata strokeColor.section	is "Colors"

--mark verticesColor
/**
Syntax:
set the verticesColor of <widget> to <pColor>
get the verticesColor of <widget>

Summary:
Sets or gets the color of the oval "handles"/"markers" at the vertices in editMode.

Parameters:
pColor: The color of the vertices (markers) , in RGB or RGBA format

Example:
set the verticesColor of widget "hhPolygon" to "255,127,0"
-- returns a _four-item_ string
get the verticesColor of widget "hhPolygon" -- "255,127,0,255"
set the verticesColor of widget "hhPolygon" to "255,127,0,127"

Description:
Use the verticesColor property to set the color of the oval "handles"/"markers" at the vertices in editMode.
The color is in the form of a 3 or 4 item string, the 4th optional item being the alpha value, all integers between 0 and 255.
[You may also use numbers containing a decimal point between 0.0 and 1.0, for example "0.2,0.1,0.2".
.: The "get" always returns _four_ items in the integer form (each in range 0-255). :.
**/
property verticesColor get getVerticesColor set setVerticesColor
metadata verticesColor.editor is "com.livecode.pi.colorwithalpha"
metadata verticesColor.section	is "Colors"

--mark fillRule
property "fillRule" get mFillRule set setFillRule
metadata fillRule.editor		is "com.livecode.pi.enum"
metadata fillRule.options		is "even odd,non-zero"
metadata filenameFill.section is "Colors"
metadata fillRule.user_visible		is "false"

--mark fillPoly
/**
Syntax:
set the fillPoly of <widget> to <pTrueOrFalse>
get the fillPoly of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the fillPoly of widget "hhPolygon" to not \
		the fillPoly of widget "hhPolygon"

Summary: If set to true property fillPoly causes the polygon path to be filled with the current fillColor.

Description:
Use the fillPoly property to fill the polygon's path. Setting the fillPoly of the widget (for the polygon path) to false sets the strokePoly of the widget (for the polygon path) to true.
**/
property "fillPoly" get mFill set setFill
metadata fillPoly.section is "Colors"

--mark strokePoly
/**
Syntax:
set the strokePoly of <widget> to <pTrueOrFalse>
get the strokePoly of <widget>

Parameters:
pTrueOrFalse: is true or false 

Example:
set the strokePoly of widget "hhPolygon" to not \
		the strokePoly of widget "hhPolygon"

Summary: If set to true property strokePoly causes the polygon path to be stroked (outlined) with the current strokeColor.

Description:
Use the strokePoly property to stroke (outline) the polygon's path. Setting the strokePoly of the widget (for the polygon path) to false sets the fillPoly of the widget (for the polygon path) to true.
**/
property "strokePoly" get mStroke set setStroke
metadata strokePoly.section is "Colors"

--mark strokeWidth
/**
Syntax:
set the strokeWidth of <widget> to <pWidth>
get the strokeWidth of <widget>

Parameters:
pWidth: A positive number

Example:
set the strokeWidth of widget "hhPolygon" to 4.2

Summary: Set or get the strokeWidth property for stroking (outlining) the polygon's path.
The bounds of the path are accordingly adjusted.

Description:
Use the strokeWidth property to determine the with of a stroked path. It's not poss
to set the strokeWidth to a value smaller than 1. Set the strokePoly property to false to disable to have no stroke/outline.
**/
property "strokeWidth" get mStrokeWidth	 set setStrokeWidth
metadata strokeWidth.editor		is "com.livecode.pi.number"
metadata strokeWidth.min		is "1"
metadata strokeWidth.max		is "24"
metadata strokeWidth.step		is "1"
metadata strokeWidth.section is "Colors"

end widget
